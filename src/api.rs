// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Experiment {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub user: ::std::string::String,
    pub time_created_secs: f64,
    pub hparam_infos: ::protobuf::RepeatedField<HParamInfo>,
    pub metric_infos: ::protobuf::RepeatedField<MetricInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Experiment {
    fn default() -> &'a Experiment {
        <Experiment as ::protobuf::Message>::default_instance()
    }
}

impl Experiment {
    pub fn new() -> Experiment {
        ::std::default::Default::default()
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 1;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // double time_created_secs = 3;


    pub fn get_time_created_secs(&self) -> f64 {
        self.time_created_secs
    }
    pub fn clear_time_created_secs(&mut self) {
        self.time_created_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time_created_secs(&mut self, v: f64) {
        self.time_created_secs = v;
    }

    // repeated .tensorboardrs.hparam.HParamInfo hparam_infos = 4;


    pub fn get_hparam_infos(&self) -> &[HParamInfo] {
        &self.hparam_infos
    }
    pub fn clear_hparam_infos(&mut self) {
        self.hparam_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_hparam_infos(&mut self, v: ::protobuf::RepeatedField<HParamInfo>) {
        self.hparam_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hparam_infos(&mut self) -> &mut ::protobuf::RepeatedField<HParamInfo> {
        &mut self.hparam_infos
    }

    // Take field
    pub fn take_hparam_infos(&mut self) -> ::protobuf::RepeatedField<HParamInfo> {
        ::std::mem::replace(&mut self.hparam_infos, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorboardrs.hparam.MetricInfo metric_infos = 5;


    pub fn get_metric_infos(&self) -> &[MetricInfo] {
        &self.metric_infos
    }
    pub fn clear_metric_infos(&mut self) {
        self.metric_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_infos(&mut self, v: ::protobuf::RepeatedField<MetricInfo>) {
        self.metric_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_infos(&mut self) -> &mut ::protobuf::RepeatedField<MetricInfo> {
        &mut self.metric_infos
    }

    // Take field
    pub fn take_metric_infos(&mut self) -> ::protobuf::RepeatedField<MetricInfo> {
        ::std::mem::replace(&mut self.metric_infos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Experiment {
    fn is_initialized(&self) -> bool {
        for v in &self.hparam_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metric_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time_created_secs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hparam_infos)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.description);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        if self.time_created_secs != 0. {
            my_size += 9;
        }
        for value in &self.hparam_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metric_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(1, &self.description)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        if self.time_created_secs != 0. {
            os.write_double(3, self.time_created_secs)?;
        }
        for v in &self.hparam_infos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metric_infos {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Experiment {
        Experiment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Experiment| { &m.name },
                |m: &mut Experiment| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Experiment| { &m.description },
                |m: &mut Experiment| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &Experiment| { &m.user },
                |m: &mut Experiment| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "time_created_secs",
                |m: &Experiment| { &m.time_created_secs },
                |m: &mut Experiment| { &mut m.time_created_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HParamInfo>>(
                "hparam_infos",
                |m: &Experiment| { &m.hparam_infos },
                |m: &mut Experiment| { &mut m.hparam_infos },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricInfo>>(
                "metric_infos",
                |m: &Experiment| { &m.metric_infos },
                |m: &mut Experiment| { &mut m.metric_infos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Experiment>(
                "Experiment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Experiment {
        static instance: ::protobuf::rt::LazyV2<Experiment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Experiment::new)
    }
}

impl ::protobuf::Clear for Experiment {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.user.clear();
        self.time_created_secs = 0.;
        self.hparam_infos.clear();
        self.metric_infos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Experiment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experiment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HParamInfo {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub field_type: DataType,
    // message oneof groups
    pub domain: ::std::option::Option<HParamInfo_oneof_domain>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HParamInfo {
    fn default() -> &'a HParamInfo {
        <HParamInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HParamInfo_oneof_domain {
    domain_discrete(::protobuf::well_known_types::ListValue),
    domain_interval(Interval),
}

impl HParamInfo {
    pub fn new() -> HParamInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.DataType type = 4;


    pub fn get_field_type(&self) -> DataType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = DataType::DATA_TYPE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataType) {
        self.field_type = v;
    }

    // .google.protobuf.ListValue domain_discrete = 5;


    pub fn get_domain_discrete(&self) -> &::protobuf::well_known_types::ListValue {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(ref v)) => v,
            _ => <::protobuf::well_known_types::ListValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_domain_discrete(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain_discrete(&self) -> bool {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_domain_discrete(&mut self, v: ::protobuf::well_known_types::ListValue) {
        self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_domain_discrete(&mut self) -> &mut ::protobuf::well_known_types::ListValue {
        if let ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(_)) = self.domain {
        } else {
            self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(::protobuf::well_known_types::ListValue::new()));
        }
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_domain_discrete(&mut self) -> ::protobuf::well_known_types::ListValue {
        if self.has_domain_discrete() {
            match self.domain.take() {
                ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::ListValue::new()
        }
    }

    // .tensorboardrs.hparam.Interval domain_interval = 6;


    pub fn get_domain_interval(&self) -> &Interval {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(ref v)) => v,
            _ => <Interval as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_domain_interval(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain_interval(&self) -> bool {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_domain_interval(&mut self, v: Interval) {
        self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(v))
    }

    // Mutable pointer to the field.
    pub fn mut_domain_interval(&mut self) -> &mut Interval {
        if let ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(_)) = self.domain {
        } else {
            self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(Interval::new()));
        }
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_domain_interval(&mut self) -> Interval {
        if self.has_domain_interval() {
            match self.domain.take() {
                ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(v)) => v,
                _ => panic!(),
            }
        } else {
            Interval::new()
        }
    }
}

impl ::protobuf::Message for HParamInfo {
    fn is_initialized(&self) -> bool {
        if let Some(HParamInfo_oneof_domain::domain_discrete(ref v)) = self.domain {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HParamInfo_oneof_domain::domain_interval(ref v)) = self.domain {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.field_type != DataType::DATA_TYPE_UNSET {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if let ::std::option::Option::Some(ref v) = self.domain {
            match v {
                &HParamInfo_oneof_domain::domain_discrete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HParamInfo_oneof_domain::domain_interval(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.field_type != DataType::DATA_TYPE_UNSET {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.domain {
            match v {
                &HParamInfo_oneof_domain::domain_discrete(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HParamInfo_oneof_domain::domain_interval(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HParamInfo {
        HParamInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HParamInfo| { &m.name },
                |m: &mut HParamInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &HParamInfo| { &m.display_name },
                |m: &mut HParamInfo| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &HParamInfo| { &m.description },
                |m: &mut HParamInfo| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataType>>(
                "type",
                |m: &HParamInfo| { &m.field_type },
                |m: &mut HParamInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::ListValue>(
                "domain_discrete",
                HParamInfo::has_domain_discrete,
                HParamInfo::get_domain_discrete,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Interval>(
                "domain_interval",
                HParamInfo::has_domain_interval,
                HParamInfo::get_domain_interval,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HParamInfo>(
                "HParamInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HParamInfo {
        static instance: ::protobuf::rt::LazyV2<HParamInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HParamInfo::new)
    }
}

impl ::protobuf::Clear for HParamInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.field_type = DataType::DATA_TYPE_UNSET;
        self.domain = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HParamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HParamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Interval {
    // message fields
    pub min_value: f64,
    pub max_value: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Interval {
    fn default() -> &'a Interval {
        <Interval as ::protobuf::Message>::default_instance()
    }
}

impl Interval {
    pub fn new() -> Interval {
        ::std::default::Default::default()
    }

    // double min_value = 1;


    pub fn get_min_value(&self) -> f64 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f64) {
        self.min_value = v;
    }

    // double max_value = 2;


    pub fn get_max_value(&self) -> f64 {
        self.max_value
    }
    pub fn clear_max_value(&mut self) {
        self.max_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_value(&mut self, v: f64) {
        self.max_value = v;
    }
}

impl ::protobuf::Message for Interval {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.min_value = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_value != 0. {
            my_size += 9;
        }
        if self.max_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_value != 0. {
            os.write_double(1, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_double(2, self.max_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Interval {
        Interval::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "min_value",
                |m: &Interval| { &m.min_value },
                |m: &mut Interval| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "max_value",
                |m: &Interval| { &m.max_value },
                |m: &mut Interval| { &mut m.max_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Interval>(
                "Interval",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Interval {
        static instance: ::protobuf::rt::LazyV2<Interval> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Interval::new)
    }
}

impl ::protobuf::Clear for Interval {
    fn clear(&mut self) {
        self.min_value = 0.;
        self.max_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Interval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Interval {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricName {
    // message fields
    pub group: ::std::string::String,
    pub tag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricName {
    fn default() -> &'a MetricName {
        <MetricName as ::protobuf::Message>::default_instance()
    }
}

impl MetricName {
    pub fn new() -> MetricName {
        ::std::default::Default::default()
    }

    // string group = 1;


    pub fn get_group(&self) -> &str {
        &self.group
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        &mut self.group
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group, ::std::string::String::new())
    }

    // string tag = 2;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetricName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group);
        }
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.group.is_empty() {
            os.write_string(1, &self.group)?;
        }
        if !self.tag.is_empty() {
            os.write_string(2, &self.tag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricName {
        MetricName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &MetricName| { &m.group },
                |m: &mut MetricName| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &MetricName| { &m.tag },
                |m: &mut MetricName| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricName>(
                "MetricName",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricName {
        static instance: ::protobuf::rt::LazyV2<MetricName> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricName::new)
    }
}

impl ::protobuf::Clear for MetricName {
    fn clear(&mut self) {
        self.group.clear();
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricInfo {
    // message fields
    pub name: ::protobuf::SingularPtrField<MetricName>,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub dataset_type: DatasetType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricInfo {
    fn default() -> &'a MetricInfo {
        <MetricInfo as ::protobuf::Message>::default_instance()
    }
}

impl MetricInfo {
    pub fn new() -> MetricInfo {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName name = 1;


    pub fn get_name(&self) -> &MetricName {
        self.name.as_ref().unwrap_or_else(|| <MetricName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: MetricName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut MetricName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> MetricName {
        self.name.take().unwrap_or_else(|| MetricName::new())
    }

    // string display_name = 3;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.DatasetType dataset_type = 5;


    pub fn get_dataset_type(&self) -> DatasetType {
        self.dataset_type
    }
    pub fn clear_dataset_type(&mut self) {
        self.dataset_type = DatasetType::DATASET_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataset_type(&mut self, v: DatasetType) {
        self.dataset_type = v;
    }
}

impl ::protobuf::Message for MetricInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataset_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if self.dataset_type != DatasetType::DATASET_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.dataset_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(3, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if self.dataset_type != DatasetType::DATASET_UNKNOWN {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.dataset_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricInfo {
        MetricInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                "name",
                |m: &MetricInfo| { &m.name },
                |m: &mut MetricInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &MetricInfo| { &m.display_name },
                |m: &mut MetricInfo| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &MetricInfo| { &m.description },
                |m: &mut MetricInfo| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatasetType>>(
                "dataset_type",
                |m: &MetricInfo| { &m.dataset_type },
                |m: &mut MetricInfo| { &mut m.dataset_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricInfo>(
                "MetricInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricInfo {
        static instance: ::protobuf::rt::LazyV2<MetricInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricInfo::new)
    }
}

impl ::protobuf::Clear for MetricInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.dataset_type = DatasetType::DATASET_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionGroup {
    // message fields
    pub name: ::std::string::String,
    pub hparams: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value>,
    pub metric_values: ::protobuf::RepeatedField<MetricValue>,
    pub sessions: ::protobuf::RepeatedField<Session>,
    pub monitor_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionGroup {
    fn default() -> &'a SessionGroup {
        <SessionGroup as ::protobuf::Message>::default_instance()
    }
}

impl SessionGroup {
    pub fn new() -> SessionGroup {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.SessionGroup.HparamsEntry hparams = 2;


    pub fn get_hparams(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        &self.hparams
    }
    pub fn clear_hparams(&mut self) {
        self.hparams.clear();
    }

    // Param is passed by value, moved
    pub fn set_hparams(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value>) {
        self.hparams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hparams(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        &mut self.hparams
    }

    // Take field
    pub fn take_hparams(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        ::std::mem::replace(&mut self.hparams, ::std::collections::HashMap::new())
    }

    // repeated .tensorboardrs.hparam.MetricValue metric_values = 3;


    pub fn get_metric_values(&self) -> &[MetricValue] {
        &self.metric_values
    }
    pub fn clear_metric_values(&mut self) {
        self.metric_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_values(&mut self, v: ::protobuf::RepeatedField<MetricValue>) {
        self.metric_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_values(&mut self) -> &mut ::protobuf::RepeatedField<MetricValue> {
        &mut self.metric_values
    }

    // Take field
    pub fn take_metric_values(&mut self) -> ::protobuf::RepeatedField<MetricValue> {
        ::std::mem::replace(&mut self.metric_values, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorboardrs.hparam.Session sessions = 4;


    pub fn get_sessions(&self) -> &[Session] {
        &self.sessions
    }
    pub fn clear_sessions(&mut self) {
        self.sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_sessions(&mut self, v: ::protobuf::RepeatedField<Session>) {
        self.sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sessions(&mut self) -> &mut ::protobuf::RepeatedField<Session> {
        &mut self.sessions
    }

    // Take field
    pub fn take_sessions(&mut self) -> ::protobuf::RepeatedField<Session> {
        ::std::mem::replace(&mut self.sessions, ::protobuf::RepeatedField::new())
    }

    // string monitor_url = 5;


    pub fn get_monitor_url(&self) -> &str {
        &self.monitor_url
    }
    pub fn clear_monitor_url(&mut self) {
        self.monitor_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitor_url(&mut self, v: ::std::string::String) {
        self.monitor_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitor_url(&mut self) -> &mut ::std::string::String {
        &mut self.monitor_url
    }

    // Take field
    pub fn take_monitor_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitor_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SessionGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sessions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(wire_type, is, &mut self.hparams)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_values)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sessions)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitor_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(2, &self.hparams);
        for value in &self.metric_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.monitor_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.monitor_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(2, &self.hparams, os)?;
        for v in &self.metric_values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sessions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.monitor_url.is_empty() {
            os.write_string(5, &self.monitor_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionGroup {
        SessionGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SessionGroup| { &m.name },
                |m: &mut SessionGroup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(
                "hparams",
                |m: &SessionGroup| { &m.hparams },
                |m: &mut SessionGroup| { &mut m.hparams },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricValue>>(
                "metric_values",
                |m: &SessionGroup| { &m.metric_values },
                |m: &mut SessionGroup| { &mut m.metric_values },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Session>>(
                "sessions",
                |m: &SessionGroup| { &m.sessions },
                |m: &mut SessionGroup| { &mut m.sessions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitor_url",
                |m: &SessionGroup| { &m.monitor_url },
                |m: &mut SessionGroup| { &mut m.monitor_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionGroup>(
                "SessionGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionGroup {
        static instance: ::protobuf::rt::LazyV2<SessionGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionGroup::new)
    }
}

impl ::protobuf::Clear for SessionGroup {
    fn clear(&mut self) {
        self.name.clear();
        self.hparams.clear();
        self.metric_values.clear();
        self.sessions.clear();
        self.monitor_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricValue {
    // message fields
    pub name: ::protobuf::SingularPtrField<MetricName>,
    pub value: f64,
    pub training_step: i32,
    pub wall_time_secs: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricValue {
    fn default() -> &'a MetricValue {
        <MetricValue as ::protobuf::Message>::default_instance()
    }
}

impl MetricValue {
    pub fn new() -> MetricValue {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName name = 1;


    pub fn get_name(&self) -> &MetricName {
        self.name.as_ref().unwrap_or_else(|| <MetricName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: MetricName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut MetricName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> MetricName {
        self.name.take().unwrap_or_else(|| MetricName::new())
    }

    // double value = 2;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // int32 training_step = 3;


    pub fn get_training_step(&self) -> i32 {
        self.training_step
    }
    pub fn clear_training_step(&mut self) {
        self.training_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_training_step(&mut self, v: i32) {
        self.training_step = v;
    }

    // double wall_time_secs = 4;


    pub fn get_wall_time_secs(&self) -> f64 {
        self.wall_time_secs
    }
    pub fn clear_wall_time_secs(&mut self) {
        self.wall_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wall_time_secs(&mut self, v: f64) {
        self.wall_time_secs = v;
    }
}

impl ::protobuf::Message for MetricValue {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.training_step = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.wall_time_secs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0. {
            my_size += 9;
        }
        if self.training_step != 0 {
            my_size += ::protobuf::rt::value_size(3, self.training_step, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.wall_time_secs != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if self.training_step != 0 {
            os.write_int32(3, self.training_step)?;
        }
        if self.wall_time_secs != 0. {
            os.write_double(4, self.wall_time_secs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricValue {
        MetricValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                "name",
                |m: &MetricValue| { &m.name },
                |m: &mut MetricValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &MetricValue| { &m.value },
                |m: &mut MetricValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "training_step",
                |m: &MetricValue| { &m.training_step },
                |m: &mut MetricValue| { &mut m.training_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "wall_time_secs",
                |m: &MetricValue| { &m.wall_time_secs },
                |m: &mut MetricValue| { &mut m.wall_time_secs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricValue>(
                "MetricValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricValue {
        static instance: ::protobuf::rt::LazyV2<MetricValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricValue::new)
    }
}

impl ::protobuf::Clear for MetricValue {
    fn clear(&mut self) {
        self.name.clear();
        self.value = 0.;
        self.training_step = 0;
        self.wall_time_secs = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Session {
    // message fields
    pub name: ::std::string::String,
    pub start_time_secs: f64,
    pub end_time_secs: f64,
    pub status: Status,
    pub model_uri: ::std::string::String,
    pub metric_values: ::protobuf::RepeatedField<MetricValue>,
    pub monitor_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Session {
    fn default() -> &'a Session {
        <Session as ::protobuf::Message>::default_instance()
    }
}

impl Session {
    pub fn new() -> Session {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // double start_time_secs = 2;


    pub fn get_start_time_secs(&self) -> f64 {
        self.start_time_secs
    }
    pub fn clear_start_time_secs(&mut self) {
        self.start_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_start_time_secs(&mut self, v: f64) {
        self.start_time_secs = v;
    }

    // double end_time_secs = 3;


    pub fn get_end_time_secs(&self) -> f64 {
        self.end_time_secs
    }
    pub fn clear_end_time_secs(&mut self) {
        self.end_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_end_time_secs(&mut self, v: f64) {
        self.end_time_secs = v;
    }

    // .tensorboardrs.hparam.Status status = 4;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::STATUS_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // string model_uri = 5;


    pub fn get_model_uri(&self) -> &str {
        &self.model_uri
    }
    pub fn clear_model_uri(&mut self) {
        self.model_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_uri(&mut self, v: ::std::string::String) {
        self.model_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_uri(&mut self) -> &mut ::std::string::String {
        &mut self.model_uri
    }

    // Take field
    pub fn take_model_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_uri, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.MetricValue metric_values = 6;


    pub fn get_metric_values(&self) -> &[MetricValue] {
        &self.metric_values
    }
    pub fn clear_metric_values(&mut self) {
        self.metric_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_values(&mut self, v: ::protobuf::RepeatedField<MetricValue>) {
        self.metric_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_values(&mut self) -> &mut ::protobuf::RepeatedField<MetricValue> {
        &mut self.metric_values
    }

    // Take field
    pub fn take_metric_values(&mut self) -> ::protobuf::RepeatedField<MetricValue> {
        ::std::mem::replace(&mut self.metric_values, ::protobuf::RepeatedField::new())
    }

    // string monitor_url = 7;


    pub fn get_monitor_url(&self) -> &str {
        &self.monitor_url
    }
    pub fn clear_monitor_url(&mut self) {
        self.monitor_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitor_url(&mut self, v: ::std::string::String) {
        self.monitor_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitor_url(&mut self) -> &mut ::std::string::String {
        &mut self.monitor_url
    }

    // Take field
    pub fn take_monitor_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitor_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Session {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.start_time_secs = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.end_time_secs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_uri)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_values)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitor_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.start_time_secs != 0. {
            my_size += 9;
        }
        if self.end_time_secs != 0. {
            my_size += 9;
        }
        if self.status != Status::STATUS_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.model_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.model_uri);
        }
        for value in &self.metric_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.monitor_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.monitor_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.start_time_secs != 0. {
            os.write_double(2, self.start_time_secs)?;
        }
        if self.end_time_secs != 0. {
            os.write_double(3, self.end_time_secs)?;
        }
        if self.status != Status::STATUS_UNKNOWN {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.model_uri.is_empty() {
            os.write_string(5, &self.model_uri)?;
        }
        for v in &self.metric_values {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.monitor_url.is_empty() {
            os.write_string(7, &self.monitor_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Session {
        Session::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Session| { &m.name },
                |m: &mut Session| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "start_time_secs",
                |m: &Session| { &m.start_time_secs },
                |m: &mut Session| { &mut m.start_time_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "end_time_secs",
                |m: &Session| { &m.end_time_secs },
                |m: &mut Session| { &mut m.end_time_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &Session| { &m.status },
                |m: &mut Session| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_uri",
                |m: &Session| { &m.model_uri },
                |m: &mut Session| { &mut m.model_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricValue>>(
                "metric_values",
                |m: &Session| { &m.metric_values },
                |m: &mut Session| { &mut m.metric_values },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitor_url",
                |m: &Session| { &m.monitor_url },
                |m: &mut Session| { &mut m.monitor_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Session>(
                "Session",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Session {
        static instance: ::protobuf::rt::LazyV2<Session> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Session::new)
    }
}

impl ::protobuf::Clear for Session {
    fn clear(&mut self) {
        self.name.clear();
        self.start_time_secs = 0.;
        self.end_time_secs = 0.;
        self.status = Status::STATUS_UNKNOWN;
        self.model_uri.clear();
        self.metric_values.clear();
        self.monitor_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Session {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Session {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetExperimentRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetExperimentRequest {
    fn default() -> &'a GetExperimentRequest {
        <GetExperimentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetExperimentRequest {
    pub fn new() -> GetExperimentRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 1;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetExperimentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.experiment_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(1, &self.experiment_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetExperimentRequest {
        GetExperimentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experiment_name",
                |m: &GetExperimentRequest| { &m.experiment_name },
                |m: &mut GetExperimentRequest| { &mut m.experiment_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetExperimentRequest>(
                "GetExperimentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetExperimentRequest {
        static instance: ::protobuf::rt::LazyV2<GetExperimentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetExperimentRequest::new)
    }
}

impl ::protobuf::Clear for GetExperimentRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetExperimentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetExperimentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSessionGroupsRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    pub allowed_statuses: ::std::vec::Vec<Status>,
    pub col_params: ::protobuf::RepeatedField<ColParams>,
    pub aggregation_type: AggregationType,
    pub aggregation_metric: ::protobuf::SingularPtrField<MetricName>,
    pub start_index: i32,
    pub slice_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSessionGroupsRequest {
    fn default() -> &'a ListSessionGroupsRequest {
        <ListSessionGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionGroupsRequest {
    pub fn new() -> ListSessionGroupsRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 6;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.Status allowed_statuses = 7;


    pub fn get_allowed_statuses(&self) -> &[Status] {
        &self.allowed_statuses
    }
    pub fn clear_allowed_statuses(&mut self) {
        self.allowed_statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_statuses(&mut self, v: ::std::vec::Vec<Status>) {
        self.allowed_statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_statuses(&mut self) -> &mut ::std::vec::Vec<Status> {
        &mut self.allowed_statuses
    }

    // Take field
    pub fn take_allowed_statuses(&mut self) -> ::std::vec::Vec<Status> {
        ::std::mem::replace(&mut self.allowed_statuses, ::std::vec::Vec::new())
    }

    // repeated .tensorboardrs.hparam.ColParams col_params = 1;


    pub fn get_col_params(&self) -> &[ColParams] {
        &self.col_params
    }
    pub fn clear_col_params(&mut self) {
        self.col_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_col_params(&mut self, v: ::protobuf::RepeatedField<ColParams>) {
        self.col_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_col_params(&mut self) -> &mut ::protobuf::RepeatedField<ColParams> {
        &mut self.col_params
    }

    // Take field
    pub fn take_col_params(&mut self) -> ::protobuf::RepeatedField<ColParams> {
        ::std::mem::replace(&mut self.col_params, ::protobuf::RepeatedField::new())
    }

    // .tensorboardrs.hparam.AggregationType aggregation_type = 2;


    pub fn get_aggregation_type(&self) -> AggregationType {
        self.aggregation_type
    }
    pub fn clear_aggregation_type(&mut self) {
        self.aggregation_type = AggregationType::AGGREGATION_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_aggregation_type(&mut self, v: AggregationType) {
        self.aggregation_type = v;
    }

    // .tensorboardrs.hparam.MetricName aggregation_metric = 3;


    pub fn get_aggregation_metric(&self) -> &MetricName {
        self.aggregation_metric.as_ref().unwrap_or_else(|| <MetricName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_aggregation_metric(&mut self) {
        self.aggregation_metric.clear();
    }

    pub fn has_aggregation_metric(&self) -> bool {
        self.aggregation_metric.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregation_metric(&mut self, v: MetricName) {
        self.aggregation_metric = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregation_metric(&mut self) -> &mut MetricName {
        if self.aggregation_metric.is_none() {
            self.aggregation_metric.set_default();
        }
        self.aggregation_metric.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregation_metric(&mut self) -> MetricName {
        self.aggregation_metric.take().unwrap_or_else(|| MetricName::new())
    }

    // int32 start_index = 4;


    pub fn get_start_index(&self) -> i32 {
        self.start_index
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: i32) {
        self.start_index = v;
    }

    // int32 slice_size = 5;


    pub fn get_slice_size(&self) -> i32 {
        self.slice_size
    }
    pub fn clear_slice_size(&mut self) {
        self.slice_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_slice_size(&mut self, v: i32) {
        self.slice_size = v;
    }
}

impl ::protobuf::Message for ListSessionGroupsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.col_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregation_metric {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.allowed_statuses, 7, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.col_params)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aggregation_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregation_metric)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slice_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.experiment_name);
        }
        for value in &self.allowed_statuses {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.col_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.aggregation_type != AggregationType::AGGREGATION_UNSET {
            my_size += ::protobuf::rt::enum_size(2, self.aggregation_type);
        }
        if let Some(ref v) = self.aggregation_metric.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.slice_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.slice_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(6, &self.experiment_name)?;
        }
        for v in &self.allowed_statuses {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.col_params {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.aggregation_type != AggregationType::AGGREGATION_UNSET {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.aggregation_type))?;
        }
        if let Some(ref v) = self.aggregation_metric.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_index != 0 {
            os.write_int32(4, self.start_index)?;
        }
        if self.slice_size != 0 {
            os.write_int32(5, self.slice_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSessionGroupsRequest {
        ListSessionGroupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experiment_name",
                |m: &ListSessionGroupsRequest| { &m.experiment_name },
                |m: &mut ListSessionGroupsRequest| { &mut m.experiment_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "allowed_statuses",
                |m: &ListSessionGroupsRequest| { &m.allowed_statuses },
                |m: &mut ListSessionGroupsRequest| { &mut m.allowed_statuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColParams>>(
                "col_params",
                |m: &ListSessionGroupsRequest| { &m.col_params },
                |m: &mut ListSessionGroupsRequest| { &mut m.col_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AggregationType>>(
                "aggregation_type",
                |m: &ListSessionGroupsRequest| { &m.aggregation_type },
                |m: &mut ListSessionGroupsRequest| { &mut m.aggregation_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                "aggregation_metric",
                |m: &ListSessionGroupsRequest| { &m.aggregation_metric },
                |m: &mut ListSessionGroupsRequest| { &mut m.aggregation_metric },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "start_index",
                |m: &ListSessionGroupsRequest| { &m.start_index },
                |m: &mut ListSessionGroupsRequest| { &mut m.start_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "slice_size",
                |m: &ListSessionGroupsRequest| { &m.slice_size },
                |m: &mut ListSessionGroupsRequest| { &mut m.slice_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSessionGroupsRequest>(
                "ListSessionGroupsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSessionGroupsRequest {
        static instance: ::protobuf::rt::LazyV2<ListSessionGroupsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSessionGroupsRequest::new)
    }
}

impl ::protobuf::Clear for ListSessionGroupsRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.allowed_statuses.clear();
        self.col_params.clear();
        self.aggregation_type = AggregationType::AGGREGATION_UNSET;
        self.aggregation_metric.clear();
        self.start_index = 0;
        self.slice_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSessionGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionGroupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColParams {
    // message fields
    pub order: SortOrder,
    pub missing_values_first: bool,
    pub exclude_missing_values: bool,
    // message oneof groups
    pub name: ::std::option::Option<ColParams_oneof_name>,
    pub filter: ::std::option::Option<ColParams_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColParams {
    fn default() -> &'a ColParams {
        <ColParams as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColParams_oneof_name {
    metric(MetricName),
    hparam(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColParams_oneof_filter {
    filter_regexp(::std::string::String),
    filter_interval(Interval),
    filter_discrete(::protobuf::well_known_types::ListValue),
}

impl ColParams {
    pub fn new() -> ColParams {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName metric = 1;


    pub fn get_metric(&self) -> &MetricName {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(ref v)) => v,
            _ => <MetricName as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metric(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_metric(&self) -> bool {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metric(&mut self, v: MetricName) {
        self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metric(&mut self) -> &mut MetricName {
        if let ::std::option::Option::Some(ColParams_oneof_name::metric(_)) = self.name {
        } else {
            self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(MetricName::new()));
        }
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metric(&mut self) -> MetricName {
        if self.has_metric() {
            match self.name.take() {
                ::std::option::Option::Some(ColParams_oneof_name::metric(v)) => v,
                _ => panic!(),
            }
        } else {
            MetricName::new()
        }
    }

    // string hparam = 2;


    pub fn get_hparam(&self) -> &str {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_hparam(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_hparam(&self) -> bool {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hparam(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hparam(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ColParams_oneof_name::hparam(_)) = self.name {
        } else {
            self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(::std::string::String::new()));
        }
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hparam(&mut self) -> ::std::string::String {
        if self.has_hparam() {
            match self.name.take() {
                ::std::option::Option::Some(ColParams_oneof_name::hparam(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .tensorboardrs.hparam.SortOrder order = 3;


    pub fn get_order(&self) -> SortOrder {
        self.order
    }
    pub fn clear_order(&mut self) {
        self.order = SortOrder::ORDER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: SortOrder) {
        self.order = v;
    }

    // bool missing_values_first = 4;


    pub fn get_missing_values_first(&self) -> bool {
        self.missing_values_first
    }
    pub fn clear_missing_values_first(&mut self) {
        self.missing_values_first = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_values_first(&mut self, v: bool) {
        self.missing_values_first = v;
    }

    // string filter_regexp = 5;


    pub fn get_filter_regexp(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_filter_regexp(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_regexp(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_regexp(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_regexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_regexp(&mut self) -> ::std::string::String {
        if self.has_filter_regexp() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .tensorboardrs.hparam.Interval filter_interval = 6;


    pub fn get_filter_interval(&self) -> &Interval {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(ref v)) => v,
            _ => <Interval as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_interval(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_interval(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_interval(&mut self, v: Interval) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_interval(&mut self) -> &mut Interval {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(Interval::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_interval(&mut self) -> Interval {
        if self.has_filter_interval() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(v)) => v,
                _ => panic!(),
            }
        } else {
            Interval::new()
        }
    }

    // .google.protobuf.ListValue filter_discrete = 7;


    pub fn get_filter_discrete(&self) -> &::protobuf::well_known_types::ListValue {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(ref v)) => v,
            _ => <::protobuf::well_known_types::ListValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_discrete(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_discrete(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_discrete(&mut self, v: ::protobuf::well_known_types::ListValue) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_discrete(&mut self) -> &mut ::protobuf::well_known_types::ListValue {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(::protobuf::well_known_types::ListValue::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_discrete(&mut self) -> ::protobuf::well_known_types::ListValue {
        if self.has_filter_discrete() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::ListValue::new()
        }
    }

    // bool exclude_missing_values = 8;


    pub fn get_exclude_missing_values(&self) -> bool {
        self.exclude_missing_values
    }
    pub fn clear_exclude_missing_values(&mut self) {
        self.exclude_missing_values = false;
    }

    // Param is passed by value, moved
    pub fn set_exclude_missing_values(&mut self, v: bool) {
        self.exclude_missing_values = v;
    }
}

impl ::protobuf::Message for ColParams {
    fn is_initialized(&self) -> bool {
        if let Some(ColParams_oneof_name::metric(ref v)) = self.name {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ColParams_oneof_filter::filter_interval(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ColParams_oneof_filter::filter_discrete(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_values_first = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exclude_missing_values = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.order != SortOrder::ORDER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.order);
        }
        if self.missing_values_first != false {
            my_size += 2;
        }
        if self.exclude_missing_values != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.name {
            match v {
                &ColParams_oneof_name::metric(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColParams_oneof_name::hparam(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ColParams_oneof_filter::filter_regexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &ColParams_oneof_filter::filter_interval(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColParams_oneof_filter::filter_discrete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.order != SortOrder::ORDER_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.order))?;
        }
        if self.missing_values_first != false {
            os.write_bool(4, self.missing_values_first)?;
        }
        if self.exclude_missing_values != false {
            os.write_bool(8, self.exclude_missing_values)?;
        }
        if let ::std::option::Option::Some(ref v) = self.name {
            match v {
                &ColParams_oneof_name::metric(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ColParams_oneof_name::hparam(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ColParams_oneof_filter::filter_regexp(ref v) => {
                    os.write_string(5, v)?;
                },
                &ColParams_oneof_filter::filter_interval(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ColParams_oneof_filter::filter_discrete(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColParams {
        ColParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MetricName>(
                "metric",
                ColParams::has_metric,
                ColParams::get_metric,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "hparam",
                ColParams::has_hparam,
                ColParams::get_hparam,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortOrder>>(
                "order",
                |m: &ColParams| { &m.order },
                |m: &mut ColParams| { &mut m.order },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_values_first",
                |m: &ColParams| { &m.missing_values_first },
                |m: &mut ColParams| { &mut m.missing_values_first },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "filter_regexp",
                ColParams::has_filter_regexp,
                ColParams::get_filter_regexp,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Interval>(
                "filter_interval",
                ColParams::has_filter_interval,
                ColParams::get_filter_interval,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::ListValue>(
                "filter_discrete",
                ColParams::has_filter_discrete,
                ColParams::get_filter_discrete,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exclude_missing_values",
                |m: &ColParams| { &m.exclude_missing_values },
                |m: &mut ColParams| { &mut m.exclude_missing_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColParams>(
                "ColParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColParams {
        static instance: ::protobuf::rt::LazyV2<ColParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColParams::new)
    }
}

impl ::protobuf::Clear for ColParams {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.order = SortOrder::ORDER_UNSPECIFIED;
        self.missing_values_first = false;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.exclude_missing_values = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSessionGroupsResponse {
    // message fields
    pub session_groups: ::protobuf::RepeatedField<SessionGroup>,
    pub total_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSessionGroupsResponse {
    fn default() -> &'a ListSessionGroupsResponse {
        <ListSessionGroupsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionGroupsResponse {
    pub fn new() -> ListSessionGroupsResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorboardrs.hparam.SessionGroup session_groups = 1;


    pub fn get_session_groups(&self) -> &[SessionGroup] {
        &self.session_groups
    }
    pub fn clear_session_groups(&mut self) {
        self.session_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_groups(&mut self, v: ::protobuf::RepeatedField<SessionGroup>) {
        self.session_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_groups(&mut self) -> &mut ::protobuf::RepeatedField<SessionGroup> {
        &mut self.session_groups
    }

    // Take field
    pub fn take_session_groups(&mut self) -> ::protobuf::RepeatedField<SessionGroup> {
        ::std::mem::replace(&mut self.session_groups, ::protobuf::RepeatedField::new())
    }

    // int32 total_size = 3;


    pub fn get_total_size(&self) -> i32 {
        self.total_size
    }
    pub fn clear_total_size(&mut self) {
        self.total_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_size(&mut self, v: i32) {
        self.total_size = v;
    }
}

impl ::protobuf::Message for ListSessionGroupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.session_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.session_groups)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.session_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.session_groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_size != 0 {
            os.write_int32(3, self.total_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSessionGroupsResponse {
        ListSessionGroupsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionGroup>>(
                "session_groups",
                |m: &ListSessionGroupsResponse| { &m.session_groups },
                |m: &mut ListSessionGroupsResponse| { &mut m.session_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_size",
                |m: &ListSessionGroupsResponse| { &m.total_size },
                |m: &mut ListSessionGroupsResponse| { &mut m.total_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSessionGroupsResponse>(
                "ListSessionGroupsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSessionGroupsResponse {
        static instance: ::protobuf::rt::LazyV2<ListSessionGroupsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSessionGroupsResponse::new)
    }
}

impl ::protobuf::Clear for ListSessionGroupsResponse {
    fn clear(&mut self) {
        self.session_groups.clear();
        self.total_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSessionGroupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionGroupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMetricEvalsRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    pub session_name: ::std::string::String,
    pub metric_name: ::protobuf::SingularPtrField<MetricName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMetricEvalsRequest {
    fn default() -> &'a ListMetricEvalsRequest {
        <ListMetricEvalsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListMetricEvalsRequest {
    pub fn new() -> ListMetricEvalsRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 3;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }

    // string session_name = 1;


    pub fn get_session_name(&self) -> &str {
        &self.session_name
    }
    pub fn clear_session_name(&mut self) {
        self.session_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_name(&mut self, v: ::std::string::String) {
        self.session_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_name(&mut self) -> &mut ::std::string::String {
        &mut self.session_name
    }

    // Take field
    pub fn take_session_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_name, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.MetricName metric_name = 2;


    pub fn get_metric_name(&self) -> &MetricName {
        self.metric_name.as_ref().unwrap_or_else(|| <MetricName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metric_name(&mut self) {
        self.metric_name.clear();
    }

    pub fn has_metric_name(&self) -> bool {
        self.metric_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metric_name(&mut self, v: MetricName) {
        self.metric_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metric_name(&mut self) -> &mut MetricName {
        if self.metric_name.is_none() {
            self.metric_name.set_default();
        }
        self.metric_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_metric_name(&mut self) -> MetricName {
        self.metric_name.take().unwrap_or_else(|| MetricName::new())
    }
}

impl ::protobuf::Message for ListMetricEvalsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metric_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.experiment_name);
        }
        if !self.session_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_name);
        }
        if let Some(ref v) = self.metric_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(3, &self.experiment_name)?;
        }
        if !self.session_name.is_empty() {
            os.write_string(1, &self.session_name)?;
        }
        if let Some(ref v) = self.metric_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMetricEvalsRequest {
        ListMetricEvalsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experiment_name",
                |m: &ListMetricEvalsRequest| { &m.experiment_name },
                |m: &mut ListMetricEvalsRequest| { &mut m.experiment_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_name",
                |m: &ListMetricEvalsRequest| { &m.session_name },
                |m: &mut ListMetricEvalsRequest| { &mut m.session_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                "metric_name",
                |m: &ListMetricEvalsRequest| { &m.metric_name },
                |m: &mut ListMetricEvalsRequest| { &mut m.metric_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMetricEvalsRequest>(
                "ListMetricEvalsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMetricEvalsRequest {
        static instance: ::protobuf::rt::LazyV2<ListMetricEvalsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMetricEvalsRequest::new)
    }
}

impl ::protobuf::Clear for ListMetricEvalsRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.session_name.clear();
        self.metric_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMetricEvalsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMetricEvalsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataType {
    DATA_TYPE_UNSET = 0,
    DATA_TYPE_STRING = 1,
    DATA_TYPE_BOOL = 2,
    DATA_TYPE_FLOAT64 = 3,
}

impl ::protobuf::ProtobufEnum for DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::DATA_TYPE_UNSET),
            1 => ::std::option::Option::Some(DataType::DATA_TYPE_STRING),
            2 => ::std::option::Option::Some(DataType::DATA_TYPE_BOOL),
            3 => ::std::option::Option::Some(DataType::DATA_TYPE_FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataType] = &[
            DataType::DATA_TYPE_UNSET,
            DataType::DATA_TYPE_STRING,
            DataType::DATA_TYPE_BOOL,
            DataType::DATA_TYPE_FLOAT64,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataType>("DataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataType {
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::DATA_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatasetType {
    DATASET_UNKNOWN = 0,
    DATASET_TRAINING = 1,
    DATASET_VALIDATION = 2,
}

impl ::protobuf::ProtobufEnum for DatasetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatasetType> {
        match value {
            0 => ::std::option::Option::Some(DatasetType::DATASET_UNKNOWN),
            1 => ::std::option::Option::Some(DatasetType::DATASET_TRAINING),
            2 => ::std::option::Option::Some(DatasetType::DATASET_VALIDATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatasetType] = &[
            DatasetType::DATASET_UNKNOWN,
            DatasetType::DATASET_TRAINING,
            DatasetType::DATASET_VALIDATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatasetType>("DatasetType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatasetType {
}

impl ::std::default::Default for DatasetType {
    fn default() -> Self {
        DatasetType::DATASET_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    STATUS_UNKNOWN = 0,
    STATUS_SUCCESS = 1,
    STATUS_FAILURE = 2,
    STATUS_RUNNING = 3,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::STATUS_UNKNOWN),
            1 => ::std::option::Option::Some(Status::STATUS_SUCCESS),
            2 => ::std::option::Option::Some(Status::STATUS_FAILURE),
            3 => ::std::option::Option::Some(Status::STATUS_RUNNING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::STATUS_UNKNOWN,
            Status::STATUS_SUCCESS,
            Status::STATUS_FAILURE,
            Status::STATUS_RUNNING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status>("Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::STATUS_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SortOrder {
    ORDER_UNSPECIFIED = 0,
    ORDER_ASC = 1,
    ORDER_DESC = 2,
}

impl ::protobuf::ProtobufEnum for SortOrder {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SortOrder> {
        match value {
            0 => ::std::option::Option::Some(SortOrder::ORDER_UNSPECIFIED),
            1 => ::std::option::Option::Some(SortOrder::ORDER_ASC),
            2 => ::std::option::Option::Some(SortOrder::ORDER_DESC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SortOrder] = &[
            SortOrder::ORDER_UNSPECIFIED,
            SortOrder::ORDER_ASC,
            SortOrder::ORDER_DESC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SortOrder>("SortOrder", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SortOrder {
}

impl ::std::default::Default for SortOrder {
    fn default() -> Self {
        SortOrder::ORDER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SortOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AggregationType {
    AGGREGATION_UNSET = 0,
    AGGREGATION_AVG = 1,
    AGGREGATION_MEDIAN = 2,
    AGGREGATION_MIN = 3,
    AGGREGATION_MAX = 4,
}

impl ::protobuf::ProtobufEnum for AggregationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AggregationType> {
        match value {
            0 => ::std::option::Option::Some(AggregationType::AGGREGATION_UNSET),
            1 => ::std::option::Option::Some(AggregationType::AGGREGATION_AVG),
            2 => ::std::option::Option::Some(AggregationType::AGGREGATION_MEDIAN),
            3 => ::std::option::Option::Some(AggregationType::AGGREGATION_MIN),
            4 => ::std::option::Option::Some(AggregationType::AGGREGATION_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AggregationType] = &[
            AggregationType::AGGREGATION_UNSET,
            AggregationType::AGGREGATION_AVG,
            AggregationType::AGGREGATION_MEDIAN,
            AggregationType::AGGREGATION_MIN,
            AggregationType::AGGREGATION_MAX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AggregationType>("AggregationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AggregationType {
}

impl ::std::default::Default for AggregationType {
    fn default() -> Self {
        AggregationType::AGGREGATION_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rsrc/api.proto\x12\x14tensorboardrs.hparam\x1a\x1cgoogle/protobuf/str\
    uct.proto\"\x8c\x02\n\nExperiment\x12\x12\n\x04name\x18\x06\x20\x01(\tR\
    \x04name\x12\x20\n\x0bdescription\x18\x01\x20\x01(\tR\x0bdescription\x12\
    \x12\n\x04user\x18\x02\x20\x01(\tR\x04user\x12*\n\x11time_created_secs\
    \x18\x03\x20\x01(\x01R\x0ftimeCreatedSecs\x12C\n\x0chparam_infos\x18\x04\
    \x20\x03(\x0b2\x20.tensorboardrs.hparam.HParamInfoR\x0bhparamInfos\x12C\
    \n\x0cmetric_infos\x18\x05\x20\x03(\x0b2\x20.tensorboardrs.hparam.Metric\
    InfoR\x0bmetricInfos\"\xb5\x02\n\nHParamInfo\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdispl\
    ayName\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x122\
    \n\x04type\x18\x04\x20\x01(\x0e2\x1e.tensorboardrs.hparam.DataTypeR\x04t\
    ype\x12E\n\x0fdomain_discrete\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.\
    ListValueH\0R\x0edomainDiscrete\x12I\n\x0fdomain_interval\x18\x06\x20\
    \x01(\x0b2\x1e.tensorboardrs.hparam.IntervalH\0R\x0edomainIntervalB\x08\
    \n\x06domain\"D\n\x08Interval\x12\x1b\n\tmin_value\x18\x01\x20\x01(\x01R\
    \x08minValue\x12\x1b\n\tmax_value\x18\x02\x20\x01(\x01R\x08maxValue\"4\n\
    \nMetricName\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05group\x12\x10\n\
    \x03tag\x18\x02\x20\x01(\tR\x03tag\"\xcd\x01\n\nMetricInfo\x124\n\x04nam\
    e\x18\x01\x20\x01(\x0b2\x20.tensorboardrs.hparam.MetricNameR\x04name\x12\
    !\n\x0cdisplay_name\x18\x03\x20\x01(\tR\x0bdisplayName\x12\x20\n\x0bdesc\
    ription\x18\x04\x20\x01(\tR\x0bdescription\x12D\n\x0cdataset_type\x18\
    \x05\x20\x01(\x0e2!.tensorboardrs.hparam.DatasetTypeR\x0bdatasetType\"\
    \xe5\x02\n\x0cSessionGroup\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12I\n\x07hparams\x18\x02\x20\x03(\x0b2/.tensorboardrs.hparam.SessionGr\
    oup.HparamsEntryR\x07hparams\x12F\n\rmetric_values\x18\x03\x20\x03(\x0b2\
    !.tensorboardrs.hparam.MetricValueR\x0cmetricValues\x129\n\x08sessions\
    \x18\x04\x20\x03(\x0b2\x1d.tensorboardrs.hparam.SessionR\x08sessions\x12\
    \x1f\n\x0bmonitor_url\x18\x05\x20\x01(\tR\nmonitorUrl\x1aR\n\x0cHparamsE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12,\n\x05value\x18\x02\
    \x20\x01(\x0b2\x16.google.protobuf.ValueR\x05value:\x028\x01\"\xa4\x01\n\
    \x0bMetricValue\x124\n\x04name\x18\x01\x20\x01(\x0b2\x20.tensorboardrs.h\
    param.MetricNameR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05va\
    lue\x12#\n\rtraining_step\x18\x03\x20\x01(\x05R\x0ctrainingStep\x12$\n\
    \x0ewall_time_secs\x18\x04\x20\x01(\x01R\x0cwallTimeSecs\"\xa5\x02\n\x07\
    Session\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12&\n\x0fstart_ti\
    me_secs\x18\x02\x20\x01(\x01R\rstartTimeSecs\x12\"\n\rend_time_secs\x18\
    \x03\x20\x01(\x01R\x0bendTimeSecs\x124\n\x06status\x18\x04\x20\x01(\x0e2\
    \x1c.tensorboardrs.hparam.StatusR\x06status\x12\x1b\n\tmodel_uri\x18\x05\
    \x20\x01(\tR\x08modelUri\x12F\n\rmetric_values\x18\x06\x20\x03(\x0b2!.te\
    nsorboardrs.hparam.MetricValueR\x0cmetricValues\x12\x1f\n\x0bmonitor_url\
    \x18\x07\x20\x01(\tR\nmonitorUrl\"?\n\x14GetExperimentRequest\x12'\n\x0f\
    experiment_name\x18\x01\x20\x01(\tR\x0eexperimentName\"\xaf\x03\n\x18Lis\
    tSessionGroupsRequest\x12'\n\x0fexperiment_name\x18\x06\x20\x01(\tR\x0ee\
    xperimentName\x12G\n\x10allowed_statuses\x18\x07\x20\x03(\x0e2\x1c.tenso\
    rboardrs.hparam.StatusR\x0fallowedStatuses\x12>\n\ncol_params\x18\x01\
    \x20\x03(\x0b2\x1f.tensorboardrs.hparam.ColParamsR\tcolParams\x12P\n\x10\
    aggregation_type\x18\x02\x20\x01(\x0e2%.tensorboardrs.hparam.Aggregation\
    TypeR\x0faggregationType\x12O\n\x12aggregation_metric\x18\x03\x20\x01(\
    \x0b2\x20.tensorboardrs.hparam.MetricNameR\x11aggregationMetric\x12\x1f\
    \n\x0bstart_index\x18\x04\x20\x01(\x05R\nstartIndex\x12\x1d\n\nslice_siz\
    e\x18\x05\x20\x01(\x05R\tsliceSize\"\xcb\x03\n\tColParams\x12:\n\x06metr\
    ic\x18\x01\x20\x01(\x0b2\x20.tensorboardrs.hparam.MetricNameH\0R\x06metr\
    ic\x12\x18\n\x06hparam\x18\x02\x20\x01(\tH\0R\x06hparam\x125\n\x05order\
    \x18\x03\x20\x01(\x0e2\x1f.tensorboardrs.hparam.SortOrderR\x05order\x120\
    \n\x14missing_values_first\x18\x04\x20\x01(\x08R\x12missingValuesFirst\
    \x12%\n\rfilter_regexp\x18\x05\x20\x01(\tH\x01R\x0cfilterRegexp\x12I\n\
    \x0ffilter_interval\x18\x06\x20\x01(\x0b2\x1e.tensorboardrs.hparam.Inter\
    valH\x01R\x0efilterInterval\x12E\n\x0ffilter_discrete\x18\x07\x20\x01(\
    \x0b2\x1a.google.protobuf.ListValueH\x01R\x0efilterDiscrete\x124\n\x16ex\
    clude_missing_values\x18\x08\x20\x01(\x08R\x14excludeMissingValuesB\x06\
    \n\x04nameB\x08\n\x06filter\"\x85\x01\n\x19ListSessionGroupsResponse\x12\
    I\n\x0esession_groups\x18\x01\x20\x03(\x0b2\".tensorboardrs.hparam.Sessi\
    onGroupR\rsessionGroups\x12\x1d\n\ntotal_size\x18\x03\x20\x01(\x05R\ttot\
    alSize\"\xa7\x01\n\x16ListMetricEvalsRequest\x12'\n\x0fexperiment_name\
    \x18\x03\x20\x01(\tR\x0eexperimentName\x12!\n\x0csession_name\x18\x01\
    \x20\x01(\tR\x0bsessionName\x12A\n\x0bmetric_name\x18\x02\x20\x01(\x0b2\
    \x20.tensorboardrs.hparam.MetricNameR\nmetricName*`\n\x08DataType\x12\
    \x13\n\x0fDATA_TYPE_UNSET\x10\0\x12\x14\n\x10DATA_TYPE_STRING\x10\x01\
    \x12\x12\n\x0eDATA_TYPE_BOOL\x10\x02\x12\x15\n\x11DATA_TYPE_FLOAT64\x10\
    \x03*P\n\x0bDatasetType\x12\x13\n\x0fDATASET_UNKNOWN\x10\0\x12\x14\n\x10\
    DATASET_TRAINING\x10\x01\x12\x16\n\x12DATASET_VALIDATION\x10\x02*X\n\x06\
    Status\x12\x12\n\x0eSTATUS_UNKNOWN\x10\0\x12\x12\n\x0eSTATUS_SUCCESS\x10\
    \x01\x12\x12\n\x0eSTATUS_FAILURE\x10\x02\x12\x12\n\x0eSTATUS_RUNNING\x10\
    \x03*A\n\tSortOrder\x12\x15\n\x11ORDER_UNSPECIFIED\x10\0\x12\r\n\tORDER_\
    ASC\x10\x01\x12\x0e\n\nORDER_DESC\x10\x02*\x7f\n\x0fAggregationType\x12\
    \x15\n\x11AGGREGATION_UNSET\x10\0\x12\x13\n\x0fAGGREGATION_AVG\x10\x01\
    \x12\x16\n\x12AGGREGATION_MEDIAN\x10\x02\x12\x13\n\x0fAGGREGATION_MIN\
    \x10\x03\x12\x13\n\x0fAGGREGATION_MAX\x10\x04J\xc3\x84\x01\n\x07\x12\x05\
    \x1e\0\x8f\x03\x01\n\x95\x0b\n\x01\x0c\x12\x03\x1e\0\x122\x94\x05\x20Cop\
    yright\x202019\x20The\x20TensorFlow\x20Authors.\x20All\x20Rights\x20Rese\
    rved.\n\nLicensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.\
    0\x20(the\x20\"License\");\nyou\x20may\x20not\x20use\x20this\x20file\x20\
    except\x20in\x20compliance\x20with\x20the\x20License.\nYou\x20may\x20obt\
    ain\x20a\x20copy\x20of\x20the\x20License\x20at\n\nhttp://www.apache.org/\
    licenses/LICENSE-2.0\n\nUnless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\ndistributed\x20und\
    er\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\
    \x20BASIS,\nWITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KI\
    ND,\x20either\x20express\x20or\x20implied.\nSee\x20the\x20License\x20for\
    \x20the\x20specific\x20language\x20governing\x20permissions\x20and\nlimi\
    tations\x20under\x20the\x20License.\n===================================\
    ===========================================2\xfd\x02\x20Defines\x20a\x20\
    proto3-based\x20REST\x20API\x20that\x20the\x20HParams\x20web-component\
    \x20of\x20the\x20plugin\n\x20would\x20use\x20to\x20read\x20data\x20from\
    \x20a\x20hyperparameter-tuning\x20experiment.\n\x20This\x20file\x20defin\
    es\x20the\x20message\x20types\x20(resources)\x20used\n\x20to\x20pass\x20\
    information\x20into\x20and\x20out\x20of\x20the\x20API\x20methods.\x20The\
    se\x20messages\x20will\x20be\n\x20transmitted\x20using\x20proto3\x20nati\
    ve\x20JSON\x20encoding.\x20See\x20http_api.md\x20for\x20a\n\x20descripti\
    on\x20of\x20the\x20actual\x20HTTP\x20API.\n2\x8d\x02\x20General\x20note:\
    \x20in\x20what\x20follows\x20we\x20use\x20the\x20field\x20'name'\x20of\
    \x20a\x20message\x20to\n\x20stores\x20its\x20id.\x20We\x20avoid\x20calli\
    ng\x20this\x20field\x20'id'\x20since\x20it\x20is\x20a\x20reserved\x20wor\
    d\n\x20in\x20Python,\x20as\x20well\x20as\x20to\x20be\x20more\x20complian\
    t\x20with\x20the\x20API\x20style\x20guide\n\x20detailed\x20in\x20https:/\
    /cloud.google.com/apis/design/.\n2d\x20IMPORTANT:\x20If\x20you\x20change\
    \x20any\x20of\x20the\x20messages\x20here,\x20make\x20sure\x20to\x20also\
    \x20update\n\x20api.d.ts\x20accordingly.\n\n\t\n\x02\x03\0\x12\x03\x20\0\
    &\n\x08\n\x01\x02\x12\x03\"\0\x1d\n\x8d\x06\n\x02\x04\0\x12\x042\0E\x01\
    \x1a\x80\x06\x20Represents\x20a\x20single\x20experiment.\n\x20An\x20expe\
    riment\x20consists\x20of\x20multiple\x20\"sessions\".\x20Typically,\x20i\
    n\x20each\x20session\n\x20a\x20model\x20is\x20trained\x20for\x20a\x20giv\
    en\x20set\x20of\x20hyperparameter\x20values.\x20In\x20each\x20session\n\
    \x20a\x20training\x20program\x20may\x20generate\x20one\x20or\x20more\x20\
    series\x20of\x20real\x20numbers--each\n\x20containing\x20the\x20evaluati\
    on\x20of\x20some\x20metric\x20on\x20the\x20model\x20at\x20different\x20t\
    raining\n\x20steps.\n\n\x20Note\x20that\x20Sessions\x20can\x20consist\
    \x20of\x20multiple\x20Tensorboard\x20\"runs\",\x20since\x20in\n\x20a\x20\
    distributed\x20Tensorflow\x20deployment,\x20training\x20can\x20be\x20acc\
    omplished\x20using\n\x20several\x20cooporating\x20processes,\x20each\x20\
    one\x20emitting\x20Summary\x20data\x20to\x20a\x20different\n\x20log\x20d\
    irectory\x20or\x20run.\x20For\x20example,\x20in\x20a\x20single\x20sessio\
    n\x20one\x20process\x20could\n\x20periodically\x20compute\x20the\x20loss\
    \x20on\x20the\x20validation\x20set,\x20and\x20another\x20could\n\x20comp\
    ute\x20the\x20loss\x20on\x20the\x20training\x20set.\n\x20NEXT_TAG:\x207\
    \n\n\n\n\x03\x04\0\x01\x12\x032\x08\x12\n\x84\x01\n\x04\x04\0\x02\0\x12\
    \x035\x02\x12\x1aw\x20--\x20Experiments\x20are\x20scoped\x20by\x20a\x20g\
    lobal\x20name.\n\x20Currently,\x20Tensorboard\x20supports\x20displaying\
    \x20data\x20for\x20a\x20single\x20experiment.\n\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x035\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x035\t\r\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x035\x10\x11\n3\n\x04\x04\0\x02\x01\x12\x038\
    \x02\x19\x1a&\x20A\x20description.\x20May\x20contain\x20markdown.\n\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x038\t\x14\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x038\x17\x18\n2\n\
    \x04\x04\0\x02\x02\x12\x03;\x02\x12\x1a%\x20An\x20id\x20for\x20the\x20ow\
    ning\x20user\x20or\x20group.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03;\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03;\t\r\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03;\x10\x11\nT\n\x04\x04\0\x02\x03\x12\x03>\x02\x1f\
    \x1aG\x20The\x20time\x20the\x20experiment\x20was\x20created.\x20In\x20se\
    conds\x20since\x20the\x20UNIX\x20epoch.\n\n\x0c\n\x05\x04\0\x02\x03\x05\
    \x12\x03>\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03>\t\x1a\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03>\x1d\x1e\nL\n\x04\x04\0\x02\x04\x12\x03A\
    \x02'\x1a?\x20Information\x20about\x20each\x20hyperparameter\x20used\x20\
    in\x20the\x20experiment.\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03A\x02\n\
    \n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03A\x0b\x15\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x03A\x16\"\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03A%&\nD\n\
    \x04\x04\0\x02\x05\x12\x03D\x02'\x1a7\x20Information\x20about\x20each\
    \x20metric\x20used\x20in\x20the\x20experiment.\n\n\x0c\n\x05\x04\0\x02\
    \x05\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03D\x0b\x15\n\
    \x0c\n\x05\x04\0\x02\x05\x01\x12\x03D\x16\"\n\x0c\n\x05\x04\0\x02\x05\
    \x03\x12\x03D%&\n\x19\n\x02\x04\x01\x12\x04H\0c\x01\x1a\r\x20NEXT_TAG:\
    \x207\n\n\n\n\x03\x04\x01\x01\x12\x03H\x08\x12\n,\n\x04\x04\x01\x02\0\
    \x12\x03J\x02\x12\x1a\x1f\x20An\x20id\x20for\x20the\x20hyperparameter.\n\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03J\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03J\x10\x11\nv\n\
    \x04\x04\x01\x02\x01\x12\x03N\x02\x1a\x1ai\x20A\x20string\x20used\x20to\
    \x20display\x20the\x20hyperparameter\x20in\x20the\x20UI.\x20If\x20empty,\
    \x20the\x20UI\n\x20will\x20display\x20the\x20'name'\x20field.\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03N\t\x15\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03N\x18\x19\n3\
    \n\x04\x04\x01\x02\x02\x12\x03Q\x02\x19\x1a&\x20A\x20description.\x20May\
    \x20contain\x20markdown.\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03Q\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03Q\t\x14\n\x0c\n\x05\x04\x01\
    \x02\x02\x03\x12\x03Q\x17\x18\n4\n\x04\x04\x01\x02\x03\x12\x03T\x02\x14\
    \x1a'\x20The\x20data\x20type\x20of\x20this\x20hyperparameter.\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x06\x12\x03T\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03T\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03T\x12\x13\n\xa9\
    \x03\n\x04\x04\x01\x08\0\x12\x04\\\x02b\x03\x1a\x9a\x03\x20Specifies\x20\
    the\x20set\x20of\x20values\x20this\x20hyperparameter\x20can\x20hold.\x20\
    The\x20UI\x20assumes\n\x20every\x20instance\x20of\x20this\x20hyperparame\
    ter\x20will\x20hold\x20a\x20value\x20from\x20this\x20set.\x20It\n\x20is\
    \x20used\x20by\x20the\x20UI\x20to\x20allow\x20filtering\x20so\x20that\
    \x20only\x20session\x20groups\x20(see\n\x20below)\x20whose\x20associated\
    \x20hyperparameter\x20value\x20\"passes\"\x20the\x20filter\x20are\n\x20d\
    isplayed.\x20If\x20this\x20is\x20not\x20populated,\x20the\x20domain\x20i\
    s\x20assumed\x20to\x20be\x20the\n\x20entire\x20domain\x20of\x20the\x20ty\
    pe\x20of\x20the\x20hyperparameter.\n\n\x0c\n\x05\x04\x01\x08\0\x01\x12\
    \x03\\\x08\x0e\nI\n\x04\x04\x01\x02\x04\x12\x03^\x042\x1a<\x20A\x20discr\
    ete\x20set\x20of\x20the\x20values\x20this\x20hyperparameter\x20can\x20ho\
    ld.\n\n\x0c\n\x05\x04\x01\x02\x04\x06\x12\x03^\x04\x1d\n\x0c\n\x05\x04\
    \x01\x02\x04\x01\x12\x03^\x1e-\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03^0\
    1\no\n\x04\x04\x01\x02\x05\x12\x03a\x04!\x1ab\x20Numeric\x20data\x20type\
    \x20only.\x20The\x20(real)\x20interval\x20from\x20which\x20values\x20of\
    \x20this\n\x20hyperparameter\x20are\x20taken.\n\n\x0c\n\x05\x04\x01\x02\
    \x05\x06\x12\x03a\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03a\r\x1c\
    \n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03a\x1f\x20\n\n\n\x02\x05\0\x12\
    \x04e\0j\x01\n\n\n\x03\x05\0\x01\x12\x03e\x05\r\n\x0b\n\x04\x05\0\x02\0\
    \x12\x03f\x02\x16\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03f\x02\x11\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03f\x14\x15\n\x0b\n\x04\x05\0\x02\x01\x12\x03g\
    \x02\x17\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03g\x02\x12\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03g\x15\x16\n\x0b\n\x04\x05\0\x02\x02\x12\x03h\x02\
    \x15\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03h\x02\x10\n\x0c\n\x05\x05\0\
    \x02\x02\x02\x12\x03h\x13\x14\n\x0b\n\x04\x05\0\x02\x03\x12\x03i\x02\x18\
    \n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03i\x02\x13\n\x0c\n\x05\x05\0\x02\
    \x03\x02\x12\x03i\x16\x17\nb\n\x02\x04\x02\x12\x04n\0q\x01\x1aV\x20Repre\
    sents\x20the\x20closed\x20interval\x20[min_value,\x20max_value]\x20of\
    \x20the\x20real\x20line.\n\x20NEXT_TAG:\x203\n\n\n\n\x03\x04\x02\x01\x12\
    \x03n\x08\x10\n\x0b\n\x04\x04\x02\x02\0\x12\x03o\x02\x17\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03o\t\
    \x12\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03o\x15\x16\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03p\x02\x17\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03p\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03p\t\x12\n\x0c\n\x05\x04\x02\
    \x02\x01\x03\x12\x03p\x15\x16\n\x1a\n\x02\x04\x03\x12\x05t\0\x92\x01\x01\
    \x1a\r\x20NEXT_TAG:\x203\n\n\n\n\x03\x04\x03\x01\x12\x03t\x08\x12\n\xb0\
    \x0c\n\x04\x04\x03\x02\0\x12\x04\x90\x01\x02\x13\x1a\xa1\x0c\x20An\x20id\
    entifier\x20for\x20a\x20metric.\x20A\x20metric\x20is\x20a\x20real-valued\
    \x20function\x20of\x20the\n\x20model.\x20The\x20UI\x20can\x20plot\x20met\
    rics\x20for\x20a\x20session\x20evaluated\x20on\x20the\x20model\x20at\n\
    \x20different\x20training\x20steps.\n\n\x20We\x20identify\x20a\x20metric\
    \x20by\x20a\x20(group,\x20tag)\x20pair\x20of\x20strings.\x20The\x20UI\
    \x20treats\n\x20both\x20of\x20these\x20as\x20opaque\x20strings.\x20The\
    \x20only\x20requirement\x20is\x20that\x20the\x20pair\n\x20uniquely\x20id\
    entifies\x20a\x20metric\x20in\x20the\x20experiment.\n\n\x20We\x20use\x20\
    a\x20pair\x20so\x20the\x20UI\x20could\x20allow\x20the\x20user\x20to\x20g\
    roup\x20metrics\x20for\x20a\n\x20single\x20session\x20by\x20either\x20gr\
    oup\x20or\x20tag\x20to\x20be\x20displayed\x20in\x20the\x20same\x20chart.\
    \n\x20For\x20instance,\x20one\x20can\x20set\x20the\x20metric\x20group\
    \x20to\x20correspond\x20to\x20the\x20dataset\n\x20on\x20which\x20the\x20\
    model\x20was\x20evaluated,\x20and\x20the\x20UI\x20can\x20then\x20display\
    \x20different\n\x20metrics\x20describing\x20the\x20same\x20underlying\
    \x20computation\x20and\x20using\x20different\n\x20datasets,\x20on\x20the\
    \x20same\x20chart.\n\n\x20When\x20exporting\x20summaries\x20from\x20Tens\
    orflow,\x20in\x20a\x20typical\x20setup,\x20a\n\x20training\x20session\
    \x20exports\x20evaluations\x20of\x20metrics\x20at\x20different\x20traini\
    ng\x20steps\n\x20as\x20Scalar-plugin\x20summaries--each\x20having\x20a\
    \x20run\x20of\x20the\x20form\n\x20\"<session_base_log_dir>/<sub_dir>\",\
    \x20and\x20some\x20associated\x20tag.\x20The\x20same\n\x20metric\x20for\
    \x20different\x20sessions\x20would\x20use\x20the\x20same\x20sub_dir\x20a\
    nd\x20tag,\x20but\n\x20would\x20have\x20a\x20different\x20session_base_l\
    og_dir.\x20For\x20example,\x20a\x20session\n\x20computing\x20two\x20metr\
    ics:\x20model\x20loss\x20on\x20the\x20validation\x20set\x20and\x20model\
    \x20loss\x20on\n\x20the\x20training\x20set,\x20can\x20export\x20these\
    \x20as\x20scalar\x20summaries\x20with\x20the\x20tag\x20\"loss\"\n\x20and\
    \x20runs\x20session_base_log_dir/validation\x20and\x20session_base_log_d\
    ir/training,\n\x20respectively.\x20In\x20this\x20setup,\x20the\x20'group\
    '\x20field\x20can\x20be\x20populated\x20with\n\x20the\x20\"sub_dir\"\x20\
    associated\x20with\x20the\x20metric,\x20and\x20the\x20'tag'\x20field\x20\
    can\x20be\n\x20populated\x20with\x20the\x20tag:\x20\"loss\".\n\n\r\n\x05\
    \x04\x03\x02\0\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\x90\x01\t\x0e\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x90\x01\x11\
    \x12\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\x91\x01\x02\x11\n\r\n\x05\x04\
    \x03\x02\x01\x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\
    \x12\x04\x91\x01\t\x0c\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x91\x01\x0f\
    \x10\n\x1b\n\x02\x04\x04\x12\x06\x95\x01\0\xa1\x01\x01\x1a\r\x20NEXT_TAG\
    :\x206\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x95\x01\x08\x12\n\x0c\n\x04\x04\
    \x04\x02\0\x12\x04\x96\x01\x02\x16\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\
    \x96\x01\x02\x0c\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x96\x01\r\x11\n\r\n\
    \x05\x04\x04\x02\0\x03\x12\x04\x96\x01\x14\x15\no\n\x04\x04\x04\x02\x01\
    \x12\x04\x9a\x01\x02\x1a\x1aa\x20A\x20string\x20used\x20to\x20display\
    \x20the\x20metric\x20in\x20the\x20UI.\x20If\x20empty,\x20the\x20UI\n\x20\
    will\x20display\x20the\x20'name'\x20field.\n\n\r\n\x05\x04\x04\x02\x01\
    \x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x9a\
    \x01\t\x15\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x9a\x01\x18\x19\n4\n\
    \x04\x04\x04\x02\x02\x12\x04\x9d\x01\x02\x19\x1a&\x20A\x20description.\
    \x20May\x20contain\x20markdown.\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\
    \x9d\x01\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x9d\x01\t\x14\n\r\
    \n\x05\x04\x04\x02\x02\x03\x12\x04\x9d\x01\x17\x18\nX\n\x04\x04\x04\x02\
    \x03\x12\x04\xa0\x01\x02\x1f\x1aJ\x20The\x20dataset\x20type\x20(validati\
    on,\x20training)\x20on\x20which\x20the\x20metric\x20is\x20computed.\n\n\
    \r\n\x05\x04\x04\x02\x03\x06\x12\x04\xa0\x01\x02\r\n\r\n\x05\x04\x04\x02\
    \x03\x01\x12\x04\xa0\x01\x0e\x1a\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\
    \xa0\x01\x1d\x1e\n\x0c\n\x02\x05\x01\x12\x06\xa3\x01\0\xa7\x01\x01\n\x0b\
    \n\x03\x05\x01\x01\x12\x04\xa3\x01\x05\x10\n\x0c\n\x04\x05\x01\x02\0\x12\
    \x04\xa4\x01\x02\x16\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xa4\x01\x02\x11\
    \n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xa4\x01\x14\x15\n\x0c\n\x04\x05\x01\
    \x02\x01\x12\x04\xa5\x01\x02\x17\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\
    \xa5\x01\x02\x12\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xa5\x01\x15\x16\n\
    \x0c\n\x04\x05\x01\x02\x02\x12\x04\xa6\x01\x02\x19\n\r\n\x05\x05\x01\x02\
    \x02\x01\x12\x04\xa6\x01\x02\x14\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\
    \xa6\x01\x17\x18\n\x93\x04\n\x02\x04\x05\x12\x06\xb1\x01\0\xc5\x01\x01\
    \x1a\x84\x04\x20In\x20some\x20experiments,\x20the\x20user\x20trains\x20a\
    \x20model\x20with\x20the\x20same\x20set\x20of\n\x20hyperparameters\x20mu\
    ltiple\x20times\x20to\x20get\x20the\x20distribution\x20of\x20metric\n\
    \x20evaluations,\x20when\x20the\x20computation\x20(such\x20as\x20the\x20\
    training\x20algorithm,\x20or\x20metric\n\x20evaluation)\x20is\x20non-det\
    erministic.\x20To\x20make\x20the\x20UI\x20aware\x20of\x20this,\x20sessio\
    ns\n\x20are\x20partitioned\x20into\x20groups:\x20each\x20group\x20consis\
    ts\x20of\x20all\x20training\x20sessions\n\x20which\x20share\x20the\x20sa\
    me\x20values\x20for\x20the\x20hyperparameters.\x20In\x20experiments\x20w\
    ith\x20no\n\x20repeated\x20executions,\x20each\x20group\x20consists\x20o\
    f\x20exactly\x20one\x20session.\n\x20NEXT_TAG:\x206\n\n\x0b\n\x03\x04\
    \x05\x01\x12\x04\xb1\x01\x08\x14\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xb2\
    \x01\x02\x12\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xb2\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\0\x01\x12\x04\xb2\x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\
    \x12\x04\xb2\x01\x10\x11\n\x82\x01\n\x04\x04\x05\x02\x01\x12\x04\xb6\x01\
    \x02C\x1at\x20Stores\x20the\x20hyperparameters\x20for\x20sessions\x20wit\
    hin\x20this\x20group\x20as\x20a\x20mapping\n\x20from\x20the\x20hyperpara\
    meter\x20name\x20to\x20its\x20value.\n\n\r\n\x05\x04\x05\x02\x01\x06\x12\
    \x04\xb6\x01\x026\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xb6\x017>\n\r\n\
    \x05\x04\x05\x02\x01\x03\x12\x04\xb6\x01AB\n\x87\x03\n\x04\x04\x05\x02\
    \x02\x12\x04\xbe\x01\x02)\x1a\xf8\x02\x20A\x20list\x20of\x20pairs\x20(me\
    tric,\x20value)--one\x20for\x20each\x20metric\x20in\x20the\x20experiment\
    .\n\x20The\x20value\x20denotes\x20the\x20evaluation\x20of\x20the\x20corr\
    esponding\x20metric\x20on\n\x20the\x20model\x20aggregated\x20across\x20t\
    he\x20sessions\x20in\x20this\x20group.\x20The\x20exact\x20method\n\x20of\
    \x20aggregation\x20is\x20specified\x20in\x20the\x20comments\x20of\x20Lis\
    tSessionGroupsRequest.\n\x20Unfortunately,\x20we\x20can't\x20store\x20th\
    ese\x20as\x20a\x20map,\x20since\x20proto\x20maps\x20can't\x20have\n\x20m\
    essage\x20keys.\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xbe\x01\x02\n\n\
    \r\n\x05\x04\x05\x02\x02\x06\x12\x04\xbe\x01\x0b\x16\n\r\n\x05\x04\x05\
    \x02\x02\x01\x12\x04\xbe\x01\x17$\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\
    \xbe\x01'(\n5\n\x04\x04\x05\x02\x03\x12\x04\xc1\x01\x02\x20\x1a'\x20The\
    \x20sessions\x20belonging\x20to\x20this\x20group.\n\n\r\n\x05\x04\x05\
    \x02\x03\x04\x12\x04\xc1\x01\x02\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\
    \xc1\x01\x0b\x12\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xc1\x01\x13\x1b\n\
    \r\n\x05\x04\x05\x02\x03\x03\x12\x04\xc1\x01\x1e\x1f\nL\n\x04\x04\x05\
    \x02\x04\x12\x04\xc4\x01\x02\x19\x1a>\x20An\x20optional\x20link\x20to\
    \x20a\x20web\x20page\x20monitoring\x20the\x20session\x20group.\n\n\r\n\
    \x05\x04\x05\x02\x04\x05\x12\x04\xc4\x01\x02\x08\n\r\n\x05\x04\x05\x02\
    \x04\x01\x12\x04\xc4\x01\t\x14\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\xc4\
    \x01\x17\x18\n\x1b\n\x02\x04\x06\x12\x06\xc8\x01\0\xd2\x01\x01\x1a\r\x20\
    NEXT_TAG:\x205\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xc8\x01\x08\x13\n\x0c\n\
    \x04\x04\x06\x02\0\x12\x04\xc9\x01\x02\x16\n\r\n\x05\x04\x06\x02\0\x06\
    \x12\x04\xc9\x01\x02\x0c\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xc9\x01\r\
    \x11\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xc9\x01\x14\x15\n\x0c\n\x04\x04\
    \x06\x02\x01\x12\x04\xcb\x01\x02\x13\n\r\n\x05\x04\x06\x02\x01\x05\x12\
    \x04\xcb\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xcb\x01\t\x0e\
    \n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xcb\x01\x11\x12\nB\n\x04\x04\x06\
    \x02\x02\x12\x04\xce\x01\x02\x1a\x1a4\x20The\x20training\x20step\x20at\
    \x20which\x20this\x20value\x20is\x20computed.\n\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\xce\x01\x02\x07\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \xce\x01\x08\x15\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xce\x01\x18\x19\n\
    Z\n\x04\x04\x06\x02\x03\x12\x04\xd1\x01\x02\x1c\x1aL\x20The\x20wall\x20t\
    ime\x20in\x20seconds\x20since\x20UNIX\x20epoch\x20at\x20which\x20this\
    \x20value\x20is\x20computed.\n\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xd1\
    \x01\x02\x08\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xd1\x01\t\x17\n\r\n\
    \x05\x04\x06\x02\x03\x03\x12\x04\xd1\x01\x1a\x1b\n\x1b\n\x02\x04\x07\x12\
    \x06\xd5\x01\0\xf0\x01\x01\x1a\r\x20NEXT_TAG:\x208\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xd5\x01\x08\x0f\nX\n\x04\x04\x07\x02\0\x12\x04\xd7\x01\x02\
    \x12\x1aJ\x20An\x20id\x20for\x20the\x20session.\x20Unique\x20within\x20a\
    n\x20experiment\x20(not\x20just\x20the\x20group).\n\n\r\n\x05\x04\x07\
    \x02\0\x05\x12\x04\xd7\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xd7\x01\t\r\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xd7\x01\x10\x11\n0\n\
    \x04\x04\x07\x02\x01\x12\x04\xda\x01\x02\x1d\x1a\"\x20In\x20seconds\x20s\
    ince\x20the\x20UNIX\x20epoch.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\
    \xda\x01\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xda\x01\t\x18\n\r\
    \n\x05\x04\x07\x02\x01\x03\x12\x04\xda\x01\x1b\x1c\nn\n\x04\x04\x07\x02\
    \x02\x12\x04\xde\x01\x02\x1b\x1a`\x20In\x20seconds\x20since\x20the\x20UN\
    IX\x20epoch.\n\x20May\x20be\x200\x20if\x20unavailable\x20or\x20the\x20se\
    ssion\x20has\x20not\x20finished\x20yet.\n\n\r\n\x05\x04\x07\x02\x02\x05\
    \x12\x04\xde\x01\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xde\x01\t\
    \x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xde\x01\x19\x1a\n5\n\x04\x04\
    \x07\x02\x03\x12\x04\xe1\x01\x02\x14\x1a'\x20May\x20be\x20STATUS_UNKNOWN\
    \x20if\x20unavailable.\n\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\xe1\x01\
    \x02\x08\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xe1\x01\t\x0f\n\r\n\x05\
    \x04\x07\x02\x03\x03\x12\x04\xe1\x01\x12\x13\n\xa5\x02\n\x04\x04\x07\x02\
    \x04\x12\x04\xe7\x01\x02\x17\x1a\x96\x02\x20A\x20URI\x20for\x20a\x20reso\
    urce\x20that\x20will\x20allow\x20the\x20user\x20to\x20reconstruct\x20the\
    \x20model\x20for\n\x20this\x20session.\x20E.g.,\x20in\x20Tensorflow\x20t\
    his\x20could\x20point\x20to\x20a\x20directory\x20where\x20the\n\x20check\
    points\x20are\x20stored.\x20Currently,\x20this\x20is\x20treated\x20opaqu\
    ely\x20by\x20the\x20UI\n\x20and\x20only\x20displayed\x20to\x20the\x20use\
    r\x20as\x20it\x20is\x20passed\x20here.\n\n\r\n\x05\x04\x07\x02\x04\x05\
    \x12\x04\xe7\x01\x02\x08\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xe7\x01\t\
    \x12\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\xe7\x01\x15\x16\n\xb3\x01\n\
    \x04\x04\x07\x02\x05\x12\x04\xec\x01\x02)\x1a\xa4\x01\x20Stores\x20each\
    \x20metric\x20evaluation\x20on\x20the\x20model\x20at\x20the\x20current\
    \x20training\x20step.\n\x20Unfortunately,\x20we\x20can't\x20store\x20the\
    se\x20as\x20a\x20map,\x20since\x20proto\x20maps\x20can't\x20have\n\x20me\
    ssage\x20keys.\n\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\xec\x01\x02\n\n\r\
    \n\x05\x04\x07\x02\x05\x06\x12\x04\xec\x01\x0b\x16\n\r\n\x05\x04\x07\x02\
    \x05\x01\x12\x04\xec\x01\x17$\n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\xec\
    \x01'(\nF\n\x04\x04\x07\x02\x06\x12\x04\xef\x01\x02\x19\x1a8\x20An\x20op\
    tional\x20link\x20to\x20a\x20web\x20page\x20monitoring\x20the\x20session\
    .\n\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\x04\
    \x07\x02\x06\x01\x12\x04\xef\x01\t\x14\n\r\n\x05\x04\x07\x02\x06\x03\x12\
    \x04\xef\x01\x17\x18\n3\n\x02\x05\x02\x12\x06\xf3\x01\0\xf8\x01\x01\x1a%\
    \x20Represents\x20the\x20status\x20of\x20a\x20Session.\n\n\x0b\n\x03\x05\
    \x02\x01\x12\x04\xf3\x01\x05\x0b\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xf4\
    \x01\x02\x15\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xf4\x01\x02\x10\n\r\n\
    \x05\x05\x02\x02\0\x02\x12\x04\xf4\x01\x13\x14\n\x0c\n\x04\x05\x02\x02\
    \x01\x12\x04\xf5\x01\x02\x15\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xf5\
    \x01\x02\x10\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xf5\x01\x13\x14\n\x0c\
    \n\x04\x05\x02\x02\x02\x12\x04\xf6\x01\x02\x15\n\r\n\x05\x05\x02\x02\x02\
    \x01\x12\x04\xf6\x01\x02\x10\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xf6\
    \x01\x13\x14\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\xf7\x01\x02\x15\n\r\n\
    \x05\x05\x02\x02\x03\x01\x12\x04\xf7\x01\x02\x10\n\r\n\x05\x05\x02\x02\
    \x03\x02\x12\x04\xf7\x01\x13\x14\nw\n\x02\x04\x08\x12\x06\xfd\x01\0\x80\
    \x02\x01\x1ai\x20Parameters\x20for\x20a\x20GetExperiment\x20API\x20call.\
    \n\x20Each\x20experiment\x20is\x20scoped\x20by\x20a\x20unique\x20global\
    \x20id.\n\x20NEXT_TAG:\x202\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xfd\x01\
    \x08\x1c\n\x18\n\x04\x04\x08\x02\0\x12\x04\xff\x01\x02\x1d\x1a\n\x20REQU\
    IRED\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xff\x01\x02\x08\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xff\x01\t\x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\
    \xff\x01\x1b\x1c\n\x8c\x02\n\x02\x04\t\x12\x06\x87\x02\0\xb8\x02\x01\x1a\
    \xfd\x01\x20Parameters\x20for\x20a\x20ListSessionGroups\x20API\x20call.\
    \n\x20Computes\x20a\x20list\x20of\x20the\x20current\x20session\x20groups\
    \x20allowing\x20for\x20filtering\x20and\n\x20sorting\x20by\x20metrics\
    \x20and\x20hyperparameter\x20values.\x20Returns\x20a\x20\"slice\"\x20of\
    \n\x20that\x20list\x20specified\x20by\x20start_index\x20and\x20slice_siz\
    e.\n\x20NEXT_TAG:\x208\n\n\x0b\n\x03\x04\t\x01\x12\x04\x87\x02\x08\x20\n\
    \x0c\n\x04\x04\t\x02\0\x12\x04\x88\x02\x02\x1d\n\r\n\x05\x04\t\x02\0\x05\
    \x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x88\x02\t\x18\
    \n\r\n\x05\x04\t\x02\0\x03\x12\x04\x88\x02\x1b\x1c\n\xa9\x01\n\x04\x04\t\
    \x02\x01\x12\x04\x8d\x02\x02'\x1a\x9a\x01\x20Filters\x20the\x20set\x20of\
    \x20sessions\x20(from\x20which\x20the\x20session\x20groups\x20are\x20for\
    med)\x20to\n\x20contain\x20only\x20these\x20sessions\x20whose\x20status\
    \x20is\x20contained\x20in\n\x20'allowed_statuses'.\n\n\r\n\x05\x04\t\x02\
    \x01\x04\x12\x04\x8d\x02\x02\n\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\x8d\
    \x02\x0b\x11\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x8d\x02\x12\"\n\r\n\x05\
    \x04\t\x02\x01\x03\x12\x04\x8d\x02%&\n\x8f\x05\n\x04\x04\t\x02\x02\x12\
    \x04\x9a\x02\x02$\x1a\x80\x05\x20A\x20list\x20of\x20ColParams\x20message\
    s--one\x20for\x20each\x20\"column\"\x20of\x20a\x20session\x20group.\x20A\
    \n\x20session\x20group\x20column\x20contains\x20either\x20a\x20metric\
    \x20evaluated\x20at\x20the\x20current\n\x20reported\x20computation\x20st\
    ep\x20or\x20a\x20hyperparameter\x20value.\x20In\x20addition\x20to\n\x20'\
    regular'\x20values,\x20a\x20column\x20may\x20take\x20on\x20a\x20special\
    \x20'missing-value'\x20which\n\x20denotes\x20that\x20the\x20hyperparamet\
    er\x20or\x20metric\x20is\x20not\x20available\n\x20for\x20the\x20session\
    \x20group\x20(for\x20example,\x20if\x20the\x20metric\x20is\x20not\x20use\
    d\x20in\x20the\n\x20group).\n\n\x20The\x20ColParams\x20messages\x20in\
    \x20the\x20repeated\x20field\x20below\x20configure\x20filtering\x20and\n\
    \x20sorting\x20of\x20the\x20resulting\x20collection\x20of\x20session\x20\
    groups.\x20See\x20the\x20comments\x20of\n\x20the\x20fields\x20in\x20the\
    \x20ColParam\x20message\x20below\x20for\x20more\x20details.\n\n\r\n\x05\
    \x04\t\x02\x02\x04\x12\x04\x9a\x02\x02\n\n\r\n\x05\x04\t\x02\x02\x06\x12\
    \x04\x9a\x02\x0b\x14\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x9a\x02\x15\x1f\
    \n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x9a\x02\"#\n\x84\x05\n\x04\x04\t\
    \x02\x03\x12\x04\xa7\x02\x02'\x1a\xf5\x04\x20Fields\x20controlling\x20ho\
    w\x20to\x20aggregate\x20metrics\x20across\x20sessions\x20within\x20a\n\
    \x20session\x20group.\n\x20If\x20aggregation_type\x20is\x20AGGREGATION_A\
    VG,\x20each\x20metric\x20value\x20of\x20the\n\x20session\x20group\x20is\
    \x20the\x20average\x20of\x20the\x20values\x20of\x20the\x20metric\x20acro\
    ss\x20the\n\x20sessions.\n\x20Otherwise,\x20the\x20session\x20group\x20m\
    etric\x20values\x20are\x20taken\x20directly\x20from\x20a\n\x20\"represen\
    tative\"\x20session\x20in\x20the\x20group,\x20selected\x20as\x20a\x20ses\
    sion\x20for\x20which\n\x20primary_metric\x20takes\x20on\x20its\x20minimu\
    m,\x20maximum,\x20or\x20median\x20value,\x20as\n\x20specified\x20by\x20t\
    he\x20choice\x20of\x20aggregation_type\x20(for\x20median,\x20if\x20the\
    \x20number\x20of\n\x20sessions\x20in\x20the\x20group\x20is\x20even,\x20a\
    \x20session\x20with\x20a\x20lower\x20\"middle\"\x20value\x20is\n\x20chos\
    en\x20as\x20the\x20representative\x20session).\n\n\r\n\x05\x04\t\x02\x03\
    \x06\x12\x04\xa7\x02\x02\x11\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xa7\x02\
    \x12\"\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xa7\x02%&\n9\n\x04\x04\t\x02\
    \x04\x12\x04\xaa\x02\x02$\x1a+\x20See\x20comment\x20for\x20'aggregation_\
    type'\x20above.\n\n\r\n\x05\x04\t\x02\x04\x06\x12\x04\xaa\x02\x02\x0c\n\
    \r\n\x05\x04\t\x02\x04\x01\x12\x04\xaa\x02\r\x1f\n\r\n\x05\x04\t\x02\x04\
    \x03\x12\x04\xaa\x02\"#\n\xd4\x01\n\x04\x04\t\x02\x05\x12\x04\xaf\x02\
    \x02\x18\x1a\xc5\x01\x20The\x20next\x20two\x20parameters\x20determine\
    \x20the\x20\"slice\"\x20of\x20the\x20full\x20list\x20of\n\x20session\x20\
    groups--sorted\x20and\x20filtered\x20by\x20the\x20parameters\x20above--t\
    o\x20return.\n\x20The\x200-based\x20index\x20of\x20the\x20first\x20sessi\
    on\x20group\x20to\x20return.\n\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xaf\
    \x02\x02\x07\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xaf\x02\x08\x13\n\r\n\
    \x05\x04\t\x02\x05\x03\x12\x04\xaf\x02\x16\x17\n\xfb\x02\n\x04\x04\t\x02\
    \x06\x12\x04\xb7\x02\x02\x17\x1a\xec\x02\x20The\x20number\x20of\x20sessi\
    on\x20groups\x20to\x20return\x20starting\x20at\x20the\x20session\x20grou\
    p\n\x20indexed\x20by\x20'start_index'.\x20The\x20actual\x20number\x20of\
    \x20session\x20groups\x20returned\n\x20is\x20min{slice_size,\x20total_si\
    ze\x20-\x20start_index},\x20where\n\x20total_size\x20is\x20the\x20number\
    \x20of\x20session\x20groups\x20in\x20the\x20full\x20list\n\x20sorted\x20\
    and\x20filtered\x20by\x20the\x20parameters\x20above\x20(if\x20start_inde\
    x\x20>\x20total_size\n\x20no\x20session\x20groups\x20are\x20returned).\n\
    \n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xb7\x02\x02\x07\n\r\n\x05\x04\t\x02\
    \x06\x01\x12\x04\xb7\x02\x08\x12\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xb7\
    \x02\x15\x16\n\xad\x01\n\x02\x04\n\x12\x06\xbd\x02\0\xed\x02\x01\x1a\x9e\
    \x01\x20Defines\x20parmeters\x20for\x20a\x20ListSessionGroupsRequest\x20\
    for\x20a\x20specific\x20column.\n\x20See\x20the\x20comment\x20for\x20\"L\
    istSessionGroupsRequest\"\x20above\x20for\x20more\x20details.\n\x20NEXT_\
    TAG:\x209\n\n\x0b\n\x03\x04\n\x01\x12\x04\xbd\x02\x08\x11\n\x0e\n\x04\
    \x04\n\x08\0\x12\x06\xbe\x02\x02\xc1\x02\x03\n\r\n\x05\x04\n\x08\0\x01\
    \x12\x04\xbe\x02\x08\x0c\n\x0c\n\x04\x04\n\x02\0\x12\x04\xbf\x02\x04\x1a\
    \n\r\n\x05\x04\n\x02\0\x06\x12\x04\xbf\x02\x04\x0e\n\r\n\x05\x04\n\x02\0\
    \x01\x12\x04\xbf\x02\x0f\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xbf\x02\
    \x18\x19\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xc0\x02\x04\x16\n\r\n\x05\x04\
    \n\x02\x01\x05\x12\x04\xc0\x02\x04\n\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\
    \xc0\x02\x0b\x11\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xc0\x02\x14\x15\n\
    \xc1\x06\n\x04\x04\n\x02\x02\x12\x04\xd1\x02\x02\x16\x1a\xb2\x06\x20Sort\
    ing.\n\x20The\x20final\x20order\x20of\x20session\x20groups\x20in\x20the\
    \x20response\x20is\x20defined\x20by\x20the\x20sub\n\x20collection\x20of\
    \x20ColParams\x20messages\x20(out\x20of\x20the\n\x20ListSessionGroupsReq\
    uest.col_params\x20repeated\x20field)\x20whose\x20'order'\x20field\n\x20\
    (below)\x20is\x20not\x20ORDER_UNSPECIFIED.\x20In\x20each\x20of\x20the\
    \x20messages\x20in\x20this\n\x20sub-collection,\x20the\x20next\x20two\
    \x20fields\x20specify\x20the\x20ordering\x20of\x20the\x20values\n\x20and\
    \x20missing_values\x20in\x20the\x20associated\x20column\x20of\x20the\x20\
    session\x20group.\x20The\n\x20order\x20of\x20the\x20ColParams\x20message\
    s\x20themselves\x20within\x20the\x20sub-collection\n\x20determines\x20th\
    e\x20\"significance\"\x20of\x20the\x20associated\x20column\x20as\x20a\
    \x20sorting\x20key:\n\x20with\x20the\x20first\x20being\x20the\x20primary\
    \x20sorting\x20key,\x20the\x20second\x20being\x20the\n\x20secondary\x20s\
    orting\x20key,\x20etc.\n\x20Note:\x20The\x20'session\x20group\x20name'\
    \x20is\x20added\x20as\x20a\x20least\x20significant\x20sorting\n\x20key\
    \x20to\x20the\x20keys\x20defined\x20by\x20the\x20user,\x20so\x20the\x20o\
    rder\x20in\x20the\x20response\x20is\x20always\n\x20deterministic.\n\n\r\
    \n\x05\x04\n\x02\x02\x06\x12\x04\xd1\x02\x02\x0b\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xd1\x02\x0c\x11\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xd1\x02\
    \x14\x15\n\xe0\x01\n\x04\x04\n\x02\x03\x12\x04\xd6\x02\x02\x20\x1a\xd1\
    \x01\x20This\x20field\x20is\x20ignored\x20if\x20order\x20is\x20ORDER_UNS\
    PECIFIED.\n\x20Otherwise,\x20if\x20true,\x20missing\x20values\x20are\x20\
    ordered\x20before\x20every\x20other\x20value\x20in\n\x20the\x20column;\
    \x20if\x20false\x20they\x20are\x20ordered\x20after\x20every\x20other\x20\
    value\x20in\x20the\n\x20column.\n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\
    \xd6\x02\x02\x06\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xd6\x02\x07\x1b\n\r\
    \n\x05\x04\n\x02\x03\x03\x12\x04\xd6\x02\x1e\x1f\n\xb6\x02\n\x04\x04\n\
    \x08\x01\x12\x06\xdd\x02\x02\xe9\x02\x03\x1a\xa5\x02\x20Filtering.\n\x20\
    The\x20'filter'\x20oneof\x20specifies\x20a\x20subset\x20of\x20the\x20dom\
    ain\x20of\x20the\x20values\x20a\x20column\n\x20may\x20take.\x20Only\x20s\
    ession\x20groups\x20with\x20each\x20of\x20their\x20column\x20values\x20b\
    elonging\n\x20to\x20this\x20subset\x20are\x20included\x20in\x20the\x20re\
    sponse.\x20If\x20this\x20field\x20is\x20not\n\x20specified,\x20the\x20su\
    bset\x20is\x20taken\x20to\x20be\x20the\x20entire\x20column\x20domain.\n\
    \n\r\n\x05\x04\n\x08\x01\x01\x12\x04\xdd\x02\x08\x0e\n\xeb\x01\n\x04\x04\
    \n\x02\x04\x12\x04\xe2\x02\x04\x1d\x1a\xdc\x01\x20Only\x20valid\x20for\
    \x20string-valued\x20hyperparameter\x20columns.\x20The\x20subset\x20is\n\
    \x20the\x20set\x20of\x20all\x20strings\x20matching\x20the\x20regular\x20\
    expression\x20stored\n\x20in\x20'regexp'\x20as\x20a\x20partial\x20match\
    \x20(use\x20'^<regexp>$'\x20to\x20have\x20a\x20full\n\x20match\x20agains\
    t\x20regexp).\n\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xe2\x02\x04\n\n\r\n\
    \x05\x04\n\x02\x04\x01\x12\x04\xe2\x02\x0b\x18\n\r\n\x05\x04\n\x02\x04\
    \x03\x12\x04\xe2\x02\x1b\x1c\nX\n\x04\x04\n\x02\x05\x12\x04\xe5\x02\x04!\
    \x1aJ\x20Only\x20valid\x20for\x20numeric-valued\x20columns.\x20The\x20su\
    bset\x20is\x20the\x20given\x20interval.\n\n\r\n\x05\x04\n\x02\x05\x06\
    \x12\x04\xe5\x02\x04\x0c\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xe5\x02\r\
    \x1c\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xe5\x02\x1f\x20\nK\n\x04\x04\n\
    \x02\x06\x12\x04\xe8\x02\x042\x1a=\x20Valid\x20for\x20all\x20data\x20typ\
    es.\x20The\x20subset\x20is\x20defined\x20explicitly.\n\n\r\n\x05\x04\n\
    \x02\x06\x06\x12\x04\xe8\x02\x04\x1d\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\
    \xe8\x02\x1e-\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xe8\x0201\nm\n\x04\x04\
    \n\x02\x07\x12\x04\xec\x02\x02\"\x1a_\x20Specifies\x20whether\x20to\x20e\
    xclude\x20session\x20groups\x20whose\x20column\x20value\x20is\x20missing\
    \n\x20from\x20the\x20response.\n\n\r\n\x05\x04\n\x02\x07\x05\x12\x04\xec\
    \x02\x02\x06\n\r\n\x05\x04\n\x02\x07\x01\x12\x04\xec\x02\x07\x1d\n\r\n\
    \x05\x04\n\x02\x07\x03\x12\x04\xec\x02\x20!\n\x0c\n\x02\x05\x03\x12\x06\
    \xef\x02\0\xf3\x02\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\xef\x02\x05\x0e\n\
    \x0c\n\x04\x05\x03\x02\0\x12\x04\xf0\x02\x02\x18\n\r\n\x05\x05\x03\x02\0\
    \x01\x12\x04\xf0\x02\x02\x13\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xf0\x02\
    \x16\x17\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xf1\x02\x02\x10\n\r\n\x05\
    \x05\x03\x02\x01\x01\x12\x04\xf1\x02\x02\x0b\n\r\n\x05\x05\x03\x02\x01\
    \x02\x12\x04\xf1\x02\x0e\x0f\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xf2\x02\
    \x02\x11\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xf2\x02\x02\x0c\n\r\n\x05\
    \x05\x03\x02\x02\x02\x12\x04\xf2\x02\x0f\x10\n\x0c\n\x02\x05\x04\x12\x06\
    \xf5\x02\0\xfb\x02\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xf5\x02\x05\x14\n\
    \x0c\n\x04\x05\x04\x02\0\x12\x04\xf6\x02\x02\x18\n\r\n\x05\x05\x04\x02\0\
    \x01\x12\x04\xf6\x02\x02\x13\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xf6\x02\
    \x16\x17\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xf7\x02\x02\x16\n\r\n\x05\
    \x05\x04\x02\x01\x01\x12\x04\xf7\x02\x02\x11\n\r\n\x05\x05\x04\x02\x01\
    \x02\x12\x04\xf7\x02\x14\x15\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xf8\x02\
    \x02\x19\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xf8\x02\x02\x14\n\r\n\x05\
    \x05\x04\x02\x02\x02\x12\x04\xf8\x02\x17\x18\n\x0c\n\x04\x05\x04\x02\x03\
    \x12\x04\xf9\x02\x02\x16\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xf9\x02\
    \x02\x11\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xf9\x02\x14\x15\n\x0c\n\
    \x04\x05\x04\x02\x04\x12\x04\xfa\x02\x02\x16\n\r\n\x05\x05\x04\x02\x04\
    \x01\x12\x04\xfa\x02\x02\x11\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xfa\
    \x02\x14\x15\nB\n\x02\x04\x0b\x12\x06\xff\x02\0\x87\x03\x01\x1a4\x20See\
    \x20ListSessionGroups\x20in\x20http_api.md.\n\x20NEXT_TAG:\x204\n\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\xff\x02\x08!\n\x0c\n\x04\x04\x0b\x02\0\x12\
    \x04\x80\x03\x02+\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x80\x03\x02\n\n\r\
    \n\x05\x04\x0b\x02\0\x06\x12\x04\x80\x03\x0b\x17\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x80\x03\x18&\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x80\x03)*\
    \n\xef\x01\n\x04\x04\x0b\x02\x01\x12\x04\x86\x03\x02\x17\x1a\xe0\x01\x20\
    Denotes\x20the\x20total\x20number\x20of\x20session\x20groups\x20in\x20th\
    e\x20full\x20filtered\x20list.\n\x20(Recall\x20that\x20this\x20response\
    \x20may\x20only\x20be\x20a\x20slice).\n\x20It\x20is\x20used\x20by\x20the\
    \x20UI\x20to\x20calculate\x20total\x20number\x20of\x20pages\x20and\x20ca\
    n\x20be\n\x20set\x20here\x20to\x20-1\x20to\x20mean\x20\"unknown\".\n\n\r\
    \n\x05\x04\x0b\x02\x01\x05\x12\x04\x86\x03\x02\x07\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\x86\x03\x08\x12\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \x86\x03\x15\x16\nG\n\x02\x04\x0c\x12\x06\x8b\x03\0\x8f\x03\x01\x1a9\x20\
    See\x20ListMetricEvalsRequest\x20in\x20http_api.md.\n\x20NEXT_TAG:\x204\
    \n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8b\x03\x08\x1e\n\x0c\n\x04\x04\x0c\
    \x02\0\x12\x04\x8c\x03\x02\x1d\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x8c\
    \x03\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x8c\x03\t\x18\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x8c\x03\x1b\x1c\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\x8d\x03\x02\x1a\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x8d\x03\
    \x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x8d\x03\t\x15\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\x8d\x03\x18\x19\n\x0c\n\x04\x04\x0c\x02\x02\
    \x12\x04\x8e\x03\x02\x1d\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\x8e\x03\
    \x02\x0c\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x8e\x03\r\x18\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\x8e\x03\x1b\x1cb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
